* GRIN Siphon Architecture

GRIN Siphon implements a Kanban-style workflow by using directories as
a pipeline of /buckets/ into which /tokens/ may be placed.
Asynchronous processes called /filters/ use a /pipe/ to read a token,
carry out an action, and pass the token onto the next bucket.

A /Token/ is a small JSON files that contain information the filters
need in order to run.  Filters log their actions to a token before
passing it down the pipe.

This architecture has several advantages:
- It is asynchronous. Each stage runs independently, improving fault
  isolation
- It is observable. You can monitor the state of the pipeline just by
  looking at the directories.
- It is restartable. Crashed stages can resume simply by rechecking
  their input directories.
- It is extensible. It is easy to add more stages or logic by inserting
  new directories and processors.


An /Orchestrator/ coordinates pipeline and the filters via a
/configuration file/, which must be customized for each
installation. The Orchestrator may be used to start and stop the
workflow, and to see the status of the processes. (Later versions of
the Orchestrator will enable operators to start and stop individual
filters and inject new filters into the running workflow.)

Outside the pipeline, a /Manager/ selects the books to be processed
from a /Ledger/ (a csv file) and puts tokens for them into a /Token
Bag/.  The Ledger and the Token Bag can be managed independent of the
orchestrated pipeline; using the Manager, an operator can /stage/ tokens
to the pipeline.

** Tokens

** Buckets

** Pipes

** Filters

** Ledger

** Token Bag

** Processing Space
